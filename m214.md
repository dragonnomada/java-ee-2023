# 214: La API de persistencia de Java

Por [Alan Badillo Salas](mailto:alan@nomadacode.com)

## Contenido

    - Introducción a la API de persistencia de Java
    - Aplicación de JPA a la aplicación JavaMart

---

## Introducción a la API de persistencia de Java

JNDI nos provee recursos JDBC que pueden ser configurados del lado del servidor y utilizados en nuestro proyectos.

Sin embargo, utilizar JDBC directamente puede provocar códigos bastante largos en cuánto al consumo de Queries (consultas al JDBC), lo provocaría que las inserciones, actualizaciones o consultas, no estén basadas en Modelos/Entidades, haciendo que una implementación MVC sea más difícil de programar y de mantener.

Por ejemplo, si nosotros tenemos una modelo/entidad llamada Cliente, tendremos que solucionar cómo guardar, actualizar, consultar y eliminar el cliente manualmente.

> **Ejemplo de la implementación manual de un modelo/entidad Cliente**

```java
public class Cliente {

	private Long clientId;
	private String nombre;
	private String apellidos;
	private String correo;
	private String direccion1;
	private String direccion2;

    // ... getters y setters

}
```

> **Ejemplo de una implementación manual para el servicio sobre los Clientes**

```java
@Stateful
public class DefaultClienteService implements ClienteService {

	@Resource(lookup = "jdbc/inventarios")
	DataSource dataSource;

	private PreparedStatement getPreparedStatement(String sql) throws SQLException {
		return dataSource.getConnection().prepareStatement(sql);
	}

	private PreparedStatement getPreparedStatement(String sql, int autoGeneratedKeys) throws SQLException {
		return dataSource.getConnection().prepareStatement(sql, autoGeneratedKeys);
	}

	@Override
	public Cliente agregarCliente(Cliente cliente) {
		String sql = "insert into clientes " + "(nombre, apellidos, correo, direccion1, direccion2) "
				+ "values (?, ?, ?, ?, ?)";

		try {

			PreparedStatement statement = dataSource.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

			statement.setString(1, cliente.getNombre());
			statement.setString(2, cliente.getApellidos());
			statement.setString(3, cliente.getCorreo());
			statement.setString(4, cliente.getDireccion1());
			statement.setString(5, cliente.getDireccion2());

			statement.executeUpdate();

			ResultSet resultSet = statement.getGeneratedKeys();

			resultSet.next();

			long clienteId = resultSet.getLong(1);

			return buscarCliente(clienteId);

		} catch (SQLException e) {
			// ??? rollback
		}

		return null;
	}

    // ... el resto de las consultas a la base de datos

}
```

### JPA - Java Persistence API

JPA (Java Presistence API) se basa en proveer mecanismos para persitir entidades hacia las bases de datos conectadas y así poder administrar y consultar modelos/entidades, en lugar de datos que provengan de las bases de datos y tengamos que mapearlos hacia los modelos o POJO que representen esos datos.

> **Ejemplo del mapeo de un Cliente a partir de un ResultSet**

```java
private Cliente mapCliente(ResultSet resultSet) {
    Cliente cliente = new Cliente();

    try {
        cliente.setClientId(resultSet.getLong("id"));
        cliente.setNombre(resultSet.getString("nombre"));
        cliente.setApellidos(resultSet.getString("apellidos"));
        cliente.setCorreo(resultSet.getString("correo"));
        cliente.setDireccion1(resultSet.getString("direccion1"));
        cliente.setDireccion2(resultSet.getString("direccion2"));
    } catch (SQLException e) {
        logger.warning("mapCliente: " + e.getMessage());
    }

    return cliente;
}
```

Con JPA podemos persistir y consultar (extraer) los objetos directamente con sus clases, sin tener que hacer código adicional.

### Entidades

Una entidad es una clase POJO que está anotada bajo `@Entity` y puede ser mapeada (transformada) a un registro en una tabla de una base de datos.

Nosotros podemos usar otras anotaciones como `@Id`, `@GeneratedValue`, `@Column`, etc. Que nos permitarán transformar los datos hacia la base de datos.

> **Ejemplo de un Modelo/Entidad llamado `Cliente`**

```java
@Entity
public class Cliente {

    @Id
    private Long id;
    private String nombre;
    private String apellidos;
    private String correo;
    private String direccion1;
    private String direccion2;

    // ... getters y setters

}
```

El modelo de cliente (o la entidad cliente) define los campos que debería tener la tabla en la base de datos llamada `cliente`, aunque podríamos modificar estas convensiones usando otras anotaciones como `@Table("clientes")`. Lo mismo para los campos, que tendrán el mismo nombre por defecto, pero podríamos alterarlos como `@Column("direccion_1")`. Con esto establecemos un sistema de mapeo/traducción entre nuestros modelos/entidades escritos sobre código y llevados automáticamente a tablas en la base de datos.

La principal ventaja, es que podemos administrar fácilmente la base de datos sin tocarla. Es decir, JNDI nos provee la base de datos esperada para nuestro sistema y en esa base de datos JPA construirá las tablas automáticamente y toda la persistencia quedará ahí.

JPA nos provee dos mecanismos para persistir y consultar las entidades almacenadas en la base de datos.

* **Usando Queries nativos o JPQL** - Podemos usar las anotaciones `@NamedQuery` o `@NamedNativeQuery` para generar consultas SQL nativas (por ejemplo, específicas de MySQL, Oracle o SQLServer), o podemos usar un lenguaje común llamado JPQL (Java Persitence Query Language), para unifcar consultas independientes de la base de datos.
* **Criteria API** - Podemos usar un API de Java para construir consultas específicas, usando un constructor de consultadas basadas en criterios, por ejemplo, decir en código `queryCriteria.select(...).where(...).skip(...)`.

### `PersistenceContext` y la Unidad Persistente

Cuando nosotros definimos el uso de JPA, necesitamos establecer unidades de persistencia llamada `Persistence Unit`, estas unidades serán definidas en un archivo llamado `src/META-INF/persistence.xml`.

Entonces, para usar una unidad persistente deberemos construir dicha unidad en el archivo de configuración de persistencia para JPA llamado  `src/META-INF/persistence.xml`. Con esto podremos recuperar la persistencia en el código bajo la anotación `@PersistenceContext(unitName = "myEntityManager")` y recuperaremos un `EntityManager` para administrar las entidades persistentes en nuestra base de datos conectada bajo JNDI y generadas bajo estrategias de creación o reconstrucción de las tablas.

> **Ejemplo del `src/META-INF/persistence.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.1"
	xmlns="http://xmlns.jcp.org/xml/ns/persistence"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
	<persistence-unit name="myEntityManager" transaction-type="JTA">
		<jta-data-source>jdbc/MyDataBase</jta-data-source>
		<properties>
			<property
				name="javax.persistence.schema-generation.database.action"
				value="create" />
		</properties>
	</persistence-unit>
</persistence>
```

> **Observa como está definida la unidad de Persistencia**

```xml
<persistence-unit name="myEntityManager" transaction-type="JTA">
    <jta-data-source>jdbc/MyDataBase</jta-data-source>
    <properties>
        <property
            name="javax.persistence.schema-generation.database.action"
            value="create" />
    </properties>
</persistence-unit>
```

Podemos observar que la unidad de persistencia que nos permitirá controlar todas las transacciones a nuestra base de datos se llama `myEntityManager` y es de tipo `JTA`, es decir, si no falla hace el *commit* y si falla hace el *rollback* automáticamente. Luego podemos ver el elemento `<jta-data-source>jdbc/MyDataBase</jta-data-source>` que hará referencia a la conexión del JDBC brindado por el servidor (GlassFish) mediante el JNDI, es decir, extraemos la conexión a la base de datos desde el JNDI llamado `jdbc/MyDataBase`. Finalmente usamos la estragia de generación de entidades como nuevas tablas, es decir, creará las tablas que hagan falta (esto sólo si la base de datos en nueva, no se use con bases de datos que ya tienen las tablas definidas).

> **Ejemplo de la inyección del `EntityManager` para administrar la persistencia de entidades y su consulta.

```java
@Stateful
public class MyBean {

    @PersistenceContext(unitName = "myEntityManager")
    EntityManager myEntityManager

    // ... (en algún método)
    // myEntityManager.persist(myEntity)

}
```